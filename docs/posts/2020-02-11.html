<!doctype html><html lang="en"><meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.6.0"><meta charset="utf-8"><meta name="description" content="The personal website of JT Archie. Includes a blog, work ethic, and projects they have worked on."><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel="stylesheet" href="https://unpkg.com/@picocss/pico@1.5.6/css/pico.classless.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pygments-rouge-css@0.1.0/github.css" integrity="sha256-+YP5+2/U/W/Ftf4q+/r0dlCXvZeQaY84PqgCyHsvyLg=" crossorigin="anonymous"><title>Exploring JIT execution of `luajit`</title><style>@media print{nav{display:none}}nav{padding-left:var(--spacing);padding-right:var(--spacing)}</style><nav><ul><li><a href="/"><span>JT Archie</span></a></ul><ul><li><a href="/posts" class="pseudo button">Blog</a><li><a href="https://github.com/jtarchie/site" target="_blank" class="pseudo button">Github</a></ul></nav><main class="content"><h1 id="exploring-jit-execution-of-luajit">Exploring JIT execution of <code>luajit</code></h1><p>I’ve always been impressed with the <a href="http://luajit.org/">LuaJIT</a> runtime. For years, Mike Pall has been praised (and rightfully so) for creating it. It is the fastest runtime for a dynamic language.<p>I’ve taken an interest in experimenting with it.<p>It can optimize dynamic code to efficient assembly instructions.<p>For example, we are calculating the sum of 1 to 100.<div class="language-lua highlighter-rouge highlight"><pre class="highlight"><code><span class="kd">local</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span> <span class="k">do</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">i</span>
<span class="k">end</span>
</code></pre></div><p>It generates efficient assembly. The assembly using <code>luajit -jdump</code>. This outputs a lot, but our interest lies in the <code>LOOP</code> scope.<pre><code class="language-assembly">-&gt;LOOP:
xorps xmm6, xmm6
cvtsi2sd xmm6, ebp
addsd xmm7, xmm6           # sum = sum + i
add ebp, +0x01             # i = i + 1
cmp ebp, +0x64             # if i &lt;= 100
jle -&gt;LOOP                 #   goto LOOP
jmp -&gt;EXIT
</code></pre><p>The numbers assigned to <code>sum</code> and <code>i</code> are used as typed information. These types don’t change during the execution of the script, and this allows the JIT to make efficient assembly instructions.<p>LuaJIT (like Lua) assumes all numbers are floating-point, though. The instruction <code>cvtsi2sd</code> converts integers to floating-point. Though this may be fast, it is an extraneous instruction.<p>I wanted to see if LuaJIT could just do integer-specific instructions by providing hints to the JIT. Lua doesn’t have a static type system, though.<div class="language-lua highlighter-rouge highlight"><pre class="highlight"><code><span class="kd">local</span> <span class="n">ffi</span> <span class="o">=</span> <span class="nb">require</span><span class="p">(</span><span class="s2">"ffi"</span><span class="p">)</span>
<span class="n">ffi</span><span class="p">.</span><span class="n">cdef</span> <span class="s">[[
    typedef struct { int v; } int_t;
]]</span>

<span class="kd">local</span> <span class="n">int</span> <span class="o">=</span> <span class="n">ffi</span><span class="p">.</span><span class="n">metatype</span><span class="p">(</span><span class="s2">"int_t"</span><span class="p">,</span> <span class="p">{})</span>
<span class="kd">local</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span> <span class="k">do</span>
        <span class="n">sum</span><span class="p">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">sum</span><span class="p">.</span><span class="n">v</span> <span class="o">+</span> <span class="n">i</span>
<span class="k">end</span>
</code></pre></div><pre><code class="language-assembly">-&gt;LOOP:
add ebp, ebx        # sum = sum + i
mov [rax+0x10], ebp # not sure what this is for
add ebx, +0x01      # i = i + 1
cmp ebx, +0x64      # if i &lt;= 100
jle -&gt;LOOP          #   goto LOOP
jmp -&gt;EXIT
</code></pre><p>We have some extraneous instructions, which don’t seem to be helpful here. Can we get this loop to be tighter.<p>With type information from <code>ffi</code> struct forces the instruction integer addition (<code>add</code>). The example above is simple and raw, but it shows how easy adding types was. LuaJIT has ways of <a href="http://luajit.org/ext_ffi_tutorial.html#metatype">abstracting the struct field</a>, so the implementation does bleed through.<p>Using the metamethods, we can have the struct use the <code>+</code> operator.<div class="language-lua highlighter-rouge highlight"><pre class="highlight"><code><span class="kd">local</span> <span class="n">ffi</span> <span class="o">=</span> <span class="nb">require</span><span class="p">(</span><span class="s2">"ffi"</span><span class="p">)</span>
<span class="n">ffi</span><span class="p">.</span><span class="n">cdef</span> <span class="s">[[
    typedef struct { int v; } int_t;
]]</span>

<span class="kd">local</span> <span class="n">int</span>
<span class="n">int</span> <span class="o">=</span> <span class="n">ffi</span><span class="p">.</span><span class="n">metatype</span><span class="p">(</span><span class="s2">"int_t"</span><span class="p">,</span> <span class="p">{</span>
        <span class="n">__add</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="n">int</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">v</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="k">end</span>
<span class="p">})</span>
<span class="kd">local</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span> <span class="k">do</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">i</span>
<span class="k">end</span>
</code></pre></div><pre><code class="language-assembly">-&gt;LOOP: add ebp, ebx # sum = sum + i
add ebx, +0x01       # i = i + 1 cmp
ebx, +0x64           # if i &lt;= 100
jle -&gt;LOOP           # goto LOOP
jmp -&gt;EXIT
</code></pre><p>Here we’ve managed to take standard lua code and optimize it using the <code>ffi</code> functionality. The JIT is using the type information for more optimized assembly.<p>The loop cannot get any tighter unless we remove the loop entirely. I have not been able to get LuaJIT to perform this optimization.</main>