<!doctype html><html lang="en"><meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.6.0"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/picnic/7.1.0/picnic.min.css" integrity="sha512-HZgZOfcUw1rxWuEBlzDis5U4HlbzR0wcWmb3FrLSKV6uhZiZpT9JSTzPJplHDmJZJFNfAReW+iDELJ1kADYHtA==" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css" integrity="sha512-PW9BfYtoXV6XYb/4FTkBoJEBM92TrGk7N324cCmF5i2dY02YvBg6ZPEAnSOZ5i2/nGPbsYFQwVzDxVVoWEKWww==" crossorigin="anonymous"><title>Ensure JIT execution of `luajit`</title><style>.content{padding:10px;max-width:960px;width:100%;margin:100px auto 500px}@media print{nav{display:none}.content{margin:0}}</style><nav class="demo"><a href="/" class="brand"><span>JT Archie</span></a><div class="menu"><a href="/posts" class="pseudo button">Blog</a> <a href="https://github.com/jtarchie/site" target="_blank" class="pseudo button">Github</a></div></nav><main class="content"><h1 id="ensure-jit-execution-of-luajit">Ensure JIT execution of <code class="prettyprint">luajit</code></h1><p>I've always been impressed with the <a href="http://luajit.org/">LuaJIT</a> runtime. Mike Pall has been praised (and rightfully so) for years for creating it. It is the fastest runtime for a dynamic language.<p>I've taken an interest in experimenting with it.<p>It has the ability to optimize dynamic code to efficient assembly instructions.<p>For example, calculating the sum of 1 to 100.<pre><code class="prettyprint lang-lua">local sum = 0
for i = 1, 100 do
    sum = sum + i
end
</code></pre><p>It will generate assembly that is efficient. We can get a print out of the assembly using <code class="prettyprint">luajit -jdump</code>. This outputs a lot, but our interest lies in the <code class="prettyprint">LOOP</code> scope.<pre><code class="prettyprint lang-assembly">-&gt;LOOP:
xorps xmm6, xmm6
cvtsi2sd xmm6, ebp
addsd xmm7, xmm6           # sum = sum + i
add ebp, +0x01             # i = i + 1
cmp ebp, +0x64             # if i &lt;= 100
jle -&gt;LOOP                 #   goto LOOP
jmp -&gt;EXIT
</code></pre><p>The numbers assigned to <code class="prettyprint">sum</code> and <code class="prettyprint">i</code> are used as typed information. These types don't change during the execution of the script. This allows the JIT to make efficient assembly instructions.<p>LuaJIT (like Lua) assumes all numbers are floating point, though. The instruction <code class="prettyprint">cvtsi2sd</code> converts integers to floating point. Though this may be fast, it is an extraneous instruction.<p>I wanted to see if LuaJIT could just do integer specific instructions. This could probably done if we could provide hints to the JIT. Lua doesn't have a static type system, though.<pre><code class="prettyprint lang-lua">local ffi = require("ffi")
ffi.cdef [[
    typedef struct { int v; } int_t;
]]

local int = ffi.metatype("int_t", {})
local sum = int(0)
for i = 1, 100 do
    sum.v = sum.v + i
end
</code></pre><pre><code class="prettyprint lang-assembly">-&gt;LOOP:
add ebp, ebx        # sum = sum + i
mov [rax+0x10], ebp # not sure what this is for
add ebx, +0x01      # i = i + 1
cmp ebx, +0x64      # if i &lt;= 100
jle -&gt;LOOP          #   goto LOOP
jmp -&gt;EXIT
</code></pre><p>We have some extraneous instructions, which don't seem to be helpful here. Can we get this loop to be tighter.<p>With type information from <code class="prettyprint">ffi</code> struct forces the instruction integer addition (<code class="prettyprint">add</code>). The example above is simple and raw, but shows how easy it was to add types. LuaJIT has ways of <a href="http://luajit.org/ext_ffi_tutorial.html#metatype">abstracting the struct field</a>, so the implementation does bleed through.<p>Using the metamethods, we can have the struct use the <code class="prettyprint">+</code> operator.<pre><code class="prettyprint lang-lua">local ffi = require("ffi")
ffi.cdef [[
    typedef struct { int v; } int_t;
]]

local int
int = ffi.metatype("int_t", {
    __add = function(a, b) return int(a.v + b) end
})
local sum = int(0)
for i = 1, 100 do
    sum = sum + i
end
</code></pre><pre><code class="prettyprint lang-assembly">-&gt;LOOP:
add ebp, ebx    # sum = sum + i
add ebx, +0x01  # i = i + 1
cmp ebx, +0x64  # if i &lt;= 100
jle -&gt;LOOP      #   goto LOOP
jmp -&gt;EXIT
</code></pre><p>Here we've managed to take standard lua code and using he <code class="prettyprint">ffi</code> functionality optimize it. The JIT is using the type information for more optimized assembly.<p>The loop cannot get any tighter, unless we remove the loop entirely. I have not been able to get LuaJIT to perform this optimization.</main><script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/run_prettify.min.js" integrity="sha512-MFn8OyBl1+xHPFpbyXJjYrUFSPOIznR5zo8sBN6eSF35K/F/PqSo3EqFfXHqhMzhQdr8z6dMsCEyIjDjBPy+4w==" crossorigin="anonymous"></script>