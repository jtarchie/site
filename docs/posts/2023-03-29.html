<!doctype html><html lang="en"><meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.6.0"><meta charset="utf-8"><meta name="description" content="The personal website of JT Archie. Includes a blog, work ethic, and projects they have worked on."><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel="stylesheet" href="https://unpkg.com/@picocss/pico@1.5.6/css/pico.classless.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pygments-rouge-css@0.1.0/github.css" integrity="sha256-+YP5+2/U/W/Ftf4q+/r0dlCXvZeQaY84PqgCyHsvyLg=" crossorigin="anonymous"><title>Debugging and Resolving Issues with Go and the `sqlite3` Library</title><style>@media print{nav{display:none}}nav{padding-left:var(--spacing);padding-right:var(--spacing)}</style><nav><ul><li><a href="/"><span>JT Archie</span></a></ul><ul><li><a href="/posts" class="pseudo button">Blog</a><li><a href="https://github.com/jtarchie/site" target="_blank" class="pseudo button">Github</a></ul></nav><main class="content"><h1 id="debugging-and-resolving-issues-with-go-and-the-sqlite3-library">Debugging and Resolving Issues with Go and the <code>sqlite3</code> Library</h1><p>I recently embarked on a journey to incorporate geographical data into a Golang program. This was an exciting exploration, as most solutions require PostgreSQL and PostGIS. However, for the project I'm working on, having a whole database would add an extra step in the deployment process. I decided that the application I'm building should either be a static website or have a self-hosted option for searching for geographical information.<p>Let's start by defining the data schema. I have a bunch of latitude and longitude coordinates, along with a title for each location. For example, store location 45 with a phone number (123) 555-1234. The objective is to build a store locator so that when you visit this company's website, you can input your location, say, Denver, Colorado, and find the closest stores. This is a standard feature on many company websites with physical locations.<p>During my investigation, I discovered that the SQLite database has an extension called Spatialite, which can perform many tasks that the PostGIS extension can do. If you're unfamiliar with SQLite, it differs from a standard database in that it doesn't rely on a client-server protocol but works with a local file. Since this data won't change frequently, this is a suitable solution. However, I encountered some technical challenges when trying to use the extension.<p>In Go, the most popular library for SQLite is <a href="https://github.com/mattn/go-sqlite3">go-sqlite3</a>. It requires CGO, which may deter some programmers, but I didn't have a hard requirement for or against CGO – I just needed to build a working feature.<p>The library allows extensions to be loaded at runtime. These extensions are named after their compiled dynamic library. For the latest version of Spatialite, the code looks like this:<div class="language-go highlighter-rouge highlight"><pre class="highlight"><code><span class="n">sql</span><span class="o">.</span><span class="n">Register</span><span class="p">(</span><span class="s">"sqlite_with_spacialite"</span><span class="p">,</span> <span class="o">&</span><span class="n">sqlite</span><span class="o">.</span><span class="n">SQLiteDriver</span><span class="p">{</span>
        <span class="n">Extensions</span><span class="o">:</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
                <span class="s">"mod_spatialite"</span><span class="p">,</span>
        <span class="p">},</span>
<span class="p">})</span>
</code></pre></div><p>This is then used with Golang's <code>database/sql</code> library with the custom driver name.<div class="language-go highlighter-rouge highlight"><pre class="highlight"><code><span class="n">db</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">sql</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="s">"sqlite_with_spacialite"</span><span class="p">,</span> <span class="s">"locations.sqlite"</span><span class="p">)</span>
<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"could not open database file: %w"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>This is a simple setup. However, I ran into issues because of being on a Mac with Apple Silicon. This is where this blog post transitions into debugging mode.<p>I installed SQLite and Spatialite using <a href="https://brew.sh/">brew</a>.<div class="language-bash highlighter-rouge highlight"><pre class="highlight"><code>brew <span class="nb">install </span>sqlite3 libspatialite spatialite-tools
</code></pre></div><p>So, let's dive in and explore how I successfully debugged and resolved the problem with the help of Google, GitHub Issues, and a bit of persistence!<p>When I ran the code, it would not execute due to an error related to the dynamic module compiled for Spatialite.<pre><code>dlopen(mod_spatialite.dylib, 0x000A): tried: 'mod_spatialite.dylib' (no such file), '/System/Volumes/Preboot/Cryptexes/OSmod_spatialite.dylib' (no such file), '/usr/lib/mod_spatialite.dylib' (no such file, not in dyld cache), 'mod_spatialite.dylib' (no such file), '/usr/local/lib/mod_spatialite.dylib'
</code></pre><p>This error message indicates that the dynamic module could not be found in a lookup path. I had to spend some time researching:<ul><li>Where is the <code>mod_spatialite.dylib</code> located?<li>How to tell CGO where to look up that file.</ul><p>On Apple Silicon, <code>brew</code> changed the location of the installation directory to <code>/opt/homebrew</code> (see this <a href="https://github.com/Homebrew/brew/issues/14810">issue</a>). I found it at <code>/opt/homebrew/lib/mod_spatialite.dylib</code>.<p>With CGO, there are options to change the lookup path for libraries via <code>ldflags</code>. The <a href="https://pkg.go.dev/cmd/link">docs</a> state that you can use <code>-r</code> to set the dynamic linker search path.<div class="language-bash highlighter-rouge highlight"><pre class="highlight"><code><span class="nv">$ </span>go run <span class="nt">--ldflags</span><span class="o">=</span><span class="nt">-r</span><span class="o">=</span>/opt/homebrew/lib main.go
fatal error: unexpected signal during runtime execution
<span class="o">[</span>signal SIGSEGV: segmentation violation <span class="nv">code</span><span class="o">=</span>0x2 <span class="nv">addr</span><span class="o">=</span>0xc00000000 <span class="nv">pc</span><span class="o">=</span>0x1028cc274]
</code></pre></div><p>This led to a runtime panic.<p>This means that the code compiled without a runtime error, but the panic caused memory access issues. It took time to pinpoint the problem. I had some leads, but I needed more concrete. I searched through any GitHub issue that mentioned Go, SQLite, and SIGSEGV. This <a href="https://github.com/canonical/dqlite/issues/179">issue</a> said a specific build tag that could be used to compile the local install SQLite – <code>--tags libsqlite3</code>.<div class="language-bash highlighter-rouge highlight"><pre class="highlight"><code><span class="nv">$ </span>go run <span class="nt">--ldflags</span><span class="o">=</span><span class="nt">-r</span><span class="o">=</span>/opt/homebrew/lib <span class="nt">--tags</span> libsqlite3 main.go
../../go/pkg/mod/github.com/mattn/go-sqlite3@v1.14.16/sqlite3_load_extension.go:25:8: could not determine kind of name <span class="k">for </span>C.sqlite3_enable_load_extension
../../go/pkg/mod/github.com/mattn/go-sqlite3@v1.14.16/sqlite3_load_extension.go:78:8: could not determine kind of name <span class="k">for </span>C.sqlite3_load_extension
</code></pre></div><p>The compilation is now failing, with no more runtime errors.<p>My Google search skills suggested that this error has to do with the compilation of the C code. The recommendations were to remove a newline before an <code>import</code> call. In Go, when importing C headers, the Go parser requires <code>import "C"</code> to be immediately after them.<p>I didn't have any <code>import "C"</code> in my codebase. After inspecting the file <code>sqlite3_load_extension.go</code>, I didn't see the problem mentioned. This required some further searching.<p>More Googling led me to this <a href="https://github.com/mattn/go-sqlite3/issues/839#issuecomment-674074775">comment</a>, which indicated that I needed to point to the <code>sqlite</code> headers. This required setting <code>CGO_CFLAGS</code>. I had to find where the headers were for the <code>sqlite</code> installation I had.<div class="language-bash highlighter-rouge highlight"><pre class="highlight"><code><span class="sb">`</span><span class="nv">$ </span>find /opt/homebrew | <span class="nb">grep </span>sqlite | <span class="nb">grep</span> <span class="s1">'\.h$'</span>
/opt/homebrew/Cellar/libspatialite/5.0.1_2/include/spatialite/sqlite.h
/opt/homebrew/Cellar/sqlite/3.41.2/include/sqlite3.h
/opt/homebrew/Cellar/sqlite/3.41.2/include/sqlite3ext.h
</code></pre></div><p>It looks like they're located in <code>/opt/homebrew/Cellar/sqlite/3.41.2</code>, which corresponds to the version that was installed.<div class="language-bash highlighter-rouge highlight"><pre class="highlight"><code><span class="nv">$ CGO_CFLAGS</span><span class="o">=</span><span class="s2">"-I/opt/homebrew/Cellar/sqlite/3.41.2/include"</span> <span class="se">\</span>
  go run <span class="se">\</span>
    <span class="nt">--ldflags</span><span class="o">=</span><span class="nt">-r</span><span class="o">=</span>/opt/homebrew/lib <span class="se">\</span>
    <span class="nt">--tags</span> libsqlite3 <span class="se">\</span>
    main.go
/opt/homebrew/Cellar/go/1.20.2/libexec/pkg/tool/darwin_arm64/link: running clang failed: <span class="nb">exit </span>status 1
ld: warning: directory not found <span class="k">for </span>option <span class="s1">'-L/usr/local/opt/sqlite/lib'</span>
Undefined symbols <span class="k">for </span>architecture arm64:
  <span class="s2">"_sqlite3_enable_load_extension"</span>, referenced from:
      __cgo_621878b5dd3b_Cfunc_sqlite3_enable_load_extension <span class="k">in </span>000007.o
     <span class="o">(</span>maybe you meant: __cgo_621878b5dd3b_Cfunc_sqlite3_enable_load_extension<span class="o">)</span>
  <span class="s2">"_sqlite3_load_extension"</span>, referenced from:
      __cgo_621878b5dd3b_Cfunc_sqlite3_load_extension <span class="k">in </span>000007.o
     <span class="o">(</span>maybe you meant: __cgo_621878b5dd3b_Cfunc_sqlite3_load_extension<span class="o">)</span>
ld: symbol<span class="o">(</span>s<span class="o">)</span> not found <span class="k">for </span>architecture arm64
clang: error: linker <span class="nb">command </span>failed with <span class="nb">exit </span>code 1 <span class="o">(</span>use <span class="nt">-v</span> to see invocation<span class="o">)</span>
</code></pre></div><p>Another compilation error. This time, however, it provided a clue to the issue.<p>The linker is searching for the SQLite dynamic library in the incorrect location. I needed to find where <code>sqlite</code> had been compiled within <code>/opt/homebrew</code> as a dynamic library.<div class="language-bash highlighter-rouge highlight"><pre class="highlight"><code><span class="nv">$ </span>find /opt/homebrew | <span class="nb">grep </span>sqlite | <span class="nb">grep </span>dylib
/opt/homebrew/Cellar/sqlite/3.41.2/lib/libsqlite3.0.dylib
/opt/homebrew/Cellar/sqlite/3.41.2/lib/libsqlite3.dylib
</code></pre></div><p>To set the location of the dynamic library, you can use <code>CGO_LDFLAGS</code>.<div class="language-bash highlighter-rouge highlight"><pre class="highlight"><code><span class="nv">CGO_CFLAGS</span><span class="o">=</span><span class="s2">"-I/opt/homebrew/Cellar/sqlite/3.41.2/include"</span> <span class="se">\</span>
<span class="nv">CGO_LDFLAGS</span><span class="o">=</span><span class="s2">"-L/opt/homebrew/Cellar/sqlite/3.41.2/lib"</span> <span class="se">\</span>
  go run <span class="se">\</span>
    <span class="nt">--ldflags</span><span class="o">=</span><span class="nt">-r</span><span class="o">=</span>/opt/homebrew/lib <span class="se">\</span>
    <span class="nt">--tags</span> libsqlite3 <span class="se">\</span>
    main.go
<span class="c"># command-line-arguments</span>
ld: warning: directory not found <span class="k">for </span>option <span class="s1">'-L/usr/local/opt/sqlite/lib'</span>
INFO program started
</code></pre></div><p>It's working! There's still a warning message, but I'm not overly concerned. Warnings can be treated as recommendations.<p>I've set up everything above in environment variables within a <code>.envrc</code> file. This allows me to avoid polluting the commands and not have to remember them.<div class="language-bash highlighter-rouge highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">GOFLAGS</span><span class="o">=</span><span class="s2">"--tags=libsqlite3 --ldflags=-r=/opt/homebrew/lib"</span>
<span class="nb">export </span><span class="nv">CGO_LDFLAGS</span><span class="o">=</span><span class="s2">"-L/opt/homebrew/Cellar/sqlite/3.41.2/lib"</span>
<span class="nb">export </span><span class="nv">CGO_CFLAGS</span><span class="o">=</span><span class="s2">"-I/opt/homebrew/Cellar/sqlite/3.41.2/include"</span>
</code></pre></div><p>This solution works, but there needs to be an issue with it. If brew upgrades sqlite, I'll need to update the directories. This can be fixed with some directory lookups within the .envrc script, but at this point, I'm done investigating this.<p>By leveraging Google and GitHub Issues, I could identify the root cause of the problem, explore various solutions, and ultimately find the one that worked for my situation. As developers, we often encounter challenges that require us to dig deep and think critically. I hope this post has shown you the value of perseverance and resourcefulness when tackling such issues. Happy coding!</main>